<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ì´ëª¨ì§€ ë¡œê·¸ë¼ì´í¬ ë˜ì „ í¬ë¡¤ëŸ¬</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: #020617;
      color: #e5e7eb;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      display: flex;
      justify-content: center;
      padding: 8px;
    }

    #game-container {
      display: flex;
      border: 1px solid #1f2937;
      background: #030712;
      border-radius: 8px;
      padding: 8px;
      gap: 8px;
      max-width: 1280px;
      width: 100%;
      min-height: 560px;
    }

    #left {
      flex: 1.4;
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 600px;
    }

    #screen {
      border: 1px solid #111827;
      background: #020617;
      border-radius: 6px;
      padding: 6px;
      min-height: 320px;
      max-height: 360px;
      font-size: 14px;
      line-height: 1.05;
      overflow: hidden;
      white-space: pre;
    }

    .tile {
      display: inline-block;
      width: 1.2em;
      text-align: center;
    }

    /* ë§ˆì„ ì´ë¯¸ì§€ ì˜ì—­ */
    #screen .town-wrapper {
      width: 90%;
      height: 190px;
      margin: 0 auto 6px auto;
      overflow: hidden;
      border-radius: 4px;
      border: 1px solid #111827;
    }
    #screen img.town-img {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: cover;
      object-position: center;
    }
    #screen .town-buttons {
      text-align: center;
      margin-bottom: 4px;
    }
    #screen .town-buttons button {
      margin: 0 4px;
      padding: 4px 8px;
      font-size: 13px;
      border-radius: 4px;
      border: 1px solid #1f2937;
      background: #111827;
      color: #e5e7eb;
      cursor: pointer;
    }
    #screen .town-buttons button:hover {
      background: #1f2937;
    }

    #log {
      border: 1px solid #111827;
      background: #020617;
      border-radius: 6px;
      padding: 6px;
      min-height: 120px;
      max-height: 180px;
      overflow-y: auto;
      font-size: 13px;
      white-space: pre-wrap;
    }

    #side {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 12px;
    }

    #mode {
      font-weight: bold;
      padding: 4px 6px;
      background: #111827;
      border-radius: 4px;
    }

    #party, #equipment, #inventory, #shop, #quests, #help, #relics {
      border: 1px solid #111827;
      background: #020617;
      border-radius: 4px;
      padding: 4px 6px;
    }
    #party, #equipment { max-height: 110px; overflow-y: auto; }
    #inventory { max-height: 160px; overflow-y: auto; }
    #shop { max-height: 140px; overflow-y: auto; }
    #quests { max-height: 120px; overflow-y: auto; }
    #relics { max-height: 80px; overflow-y: auto; }

    .party-member {
      padding: 2px 4px;
      border-radius: 3px;
      cursor: pointer;
      margin-bottom: 2px;
    }
    .party-member.selected {
      background: #0f172a;
      border: 1px solid #22c55e;
    }

    .slot-line {
      display: flex;
      justify-content: space-between;
      margin-bottom: 2px;
      cursor: pointer;
    }
    .slot-name { color: #9ca3af; }

    .item-row {
      display: flex;
      gap: 2px;
      margin-bottom: 2px;
    }
    .item-btn {
      flex: 1 1 auto;
      text-align: left;
      padding: 2px 4px;
      border-radius: 3px;
      border: 1px solid #111827;
      background: #020617;
      cursor: pointer;
      font-family: inherit;
      font-size: 12px;
    }
    .item-btn:hover { background: #0f172a; }

    .sell-btn {
      flex: 0 0 auto;
      padding: 2px 4px;
      border-radius: 3px;
      border: 1px solid #1f2937;
      background: #111827;
      color: #e5e7eb;
      cursor: pointer;
      font-size: 11px;
    }
    .sell-btn:hover { background: #1f2937; }

    .shop-btn, .quest-btn {
      margin-top: 4px;
      padding: 2px 4px;
      font-size: 12px;
      border-radius: 3px;
      border: 1px solid #1f2937;
      background: #111827;
      color: #e5e7eb;
      cursor: pointer;
    }
    .shop-btn:hover, .quest-btn:hover { background: #1f2937; }

    .rarity-normal  { color: #d4d4d4; }
    .rarity-magic   { color: #60a5fa; }
    .rarity-rare    { color: #facc15; }
    .rarity-unique  { color: #fb923c; }
    .rarity-legend  { color: #a855f7; }
    .rarity-epic    { color: #f97373; }

    .item-consumable { color: #4ade80; } /* ì†Œëª¨í’ˆ: ë…¹ìƒ‰ */

    .quest-card {
      border-bottom: 1px solid #111827;
      padding: 2px 0;
      margin-bottom: 2px;
    }
    .quest-title { font-weight: bold; }
    .quest-meta  { font-size: 11px; color: #9ca3af; }

    #help { font-size: 11px; color: #9ca3af; white-space: pre-wrap; }
    #help details summary {
      cursor: pointer;
      list-style: none;
      outline: none;
    }

    @media (max-width: 900px) {
      body { padding: 4px; }
      #game-container {
        flex-direction: column;
        min-height: unset;
      }
      #left { min-width: 0; }
      #screen { font-size: 12px; min-height: 260px; max-height: 260px; }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="left">
      <pre id="screen"></pre>
      <div id="log"></div>
    </div>
    <div id="side">
      <div id="mode"></div>
      <div id="party"></div>
      <div id="equipment"></div>
      <div id="inventory"></div>
      <div id="relics"></div>
      <div id="shop"></div>
      <div id="quests"></div>
      <div id="help"></div>
    </div>
  </div>

  <script>
    // ===== ì„¤ì •ê°’ =====
    const MAP_W = 50;
    const MAP_H = 25;
    const MAX_ROOMS = 9;

    // í™”ë©´ì— ë³´ì´ëŠ” ë˜ì „ ì˜ì—­: 40 x 21
    const VIEW_W = 40;
    const VIEW_H = 21;
    const BASE_FOV_RADIUS = 7;

    // íƒ€ì¼ ìƒìˆ˜
    const TILE_WALL   = '#';
    const TILE_FLOOR  = '.';
    const TILE_STAIRS = '>';
    const TILE_CHEST  = 'C';
    const TILE_TRAP   = '^';
    const TILE_ALTAR  = 'A';
    const TILE_CAMP   = 'F';
    const TILE_MERCH  = 'T';

    let mode = 'town';   // 'town' | 'dungeon'
    let floor = 1;
    let gold = 200;      // ì‹œì‘ ê³¨ë“œ 200
    let gameCleared = false;

    let party = [];
    let partyPositions = [];
    let selectedHeroIndex = 0;

    let inventory = [];
    let shopItems = [];

    // ë˜ì „ ìƒíƒœ
    let dungeonMap = [];
    let playerX = 0, playerY = 0;
    let monsters = [];
    let chests = [];
    let traps = [];
    let altars = [];
    let campfires = [];
    let merchants = [];
    let visible = [];
    let explored = [];
    let bossAlive = false;
    let exitOpen = false;

    let turnCount = 0;

    // ì˜ë¢°
    let quests = [];
    let nextQuestId = 1;

    // ìœ ë¬¼
    let relics = [];

    // ëª¬ìŠ¤í„° íƒ€ì…
    const MONSTER_TYPES = [
      { id: 'slime',    name: 'ìŠ¬ë¼ì„',   emoji: 'ğŸ§«',   hpMul: 1.0, atkMul: 0.8, defMul: 0.7 },
      { id: 'goblin',   name: 'ê³ ë¸”ë¦°',   emoji: 'ğŸ‘º',   hpMul: 1.0, atkMul: 1.0, defMul: 1.0 },
      { id: 'spider',   name: 'ê±°ë¯¸',     emoji: 'ğŸ•·ï¸',  hpMul: 0.9, atkMul: 1.1, defMul: 0.9 },
      { id: 'bat',      name: 'ë°•ì¥',     emoji: 'ğŸ¦‡',   hpMul: 0.7, atkMul: 0.9, defMul: 0.8 },
      { id: 'skeleton', name: 'ìŠ¤ì¼ˆë ˆí†¤', emoji: 'ğŸ’€',   hpMul: 1.1, atkMul: 1.0, defMul: 1.1 },
      { id: 'orc',      name: 'ì˜¤í¬',     emoji: 'ğŸ‘¹',   hpMul: 1.3, atkMul: 1.2, defMul: 1.1 },
      { id: 'zombie',   name: 'ì¢€ë¹„',     emoji: 'ğŸ§Ÿâ€â™‚ï¸', hpMul: 1.2, atkMul: 0.9, defMul: 1.0 }
    ];
    const BOSS_TYPES = [
      { id: 'ogre',  name: 'ì˜¤ìš°ê±°', emoji: 'ğŸ§Œ', hpMul: 1.4, atkMul: 1.3, defMul: 1.2 },
      { id: 'demon', name: 'ì•…ë§ˆ',   emoji: 'ğŸ˜ˆ', hpMul: 1.2, atkMul: 1.5, defMul: 1.1 }
    ];
    const DEMON_LORD = { id: 'demonlord', name: 'ë§ˆì™•', emoji: 'ğŸ‘¿', hpMul: 2.2, atkMul: 1.8, defMul: 1.7 };

    // ìœ ë¬¼
    const RELIC_POOL = [
      { id: 'lucky',   name: 'í–‰ìš´ì˜ ë™ì „',      desc: 'í¬ê·€ ì¥ë¹„ ë“œë í™•ë¥ ì´ ì†Œí­ ì¦ê°€í•©ë‹ˆë‹¤.' },
      { id: 'lantern', name: 'ì •ì°° ë“±ë¶ˆ',        desc: 'ì‹œì•¼ ë²”ìœ„ê°€ +1 ì¦ê°€í•©ë‹ˆë‹¤.' },
      { id: 'blood',   name: 'í”¼ì˜ ë¶€ì ',        desc: 'ëª¬ìŠ¤í„° ì²˜ì¹˜ ì‹œ íŒŒí‹°ê°€ ì¡°ê¸ˆ íšŒë³µí•©ë‹ˆë‹¤.' },
      { id: 'focus',   name: 'ë§ˆë ¥ ì¦í­ êµ¬ìŠ¬',   desc: 'ìŠ¤í¬ë¡¤ ê³„ì—´ ë§ˆë²•ì˜ íš¨ìœ¨ì´ ì¦ê°€í•©ë‹ˆë‹¤.' }
    ];

    // ì•„ì´ì½˜
    function heroEmoji(hero) {
      switch (hero.cls) {
        case 'warrior':  return 'ğŸ‘¨';   // ìš©ì‚¬
        case 'knight':   return 'ğŸ¤´';
        case 'archer':   return 'ğŸ¹';
        case 'monk':     return 'ğŸ§˜';
        case 'mage':     return 'ğŸ§™â€â™‚ï¸';
        case 'rogue':    return 'ğŸ•µï¸â€â™‚ï¸';
        case 'guardian': return 'ğŸ›¡ï¸';
        default:         return 'ğŸ™‚';
      }
    }

    // ìœ í‹¸
    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
    function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }
    function hasRelic(id) { return relics.some(r => r.id === id); }

    // ===== ì˜ì›… / íŒŒí‹° =====
    function classLabel(cls) {
      switch (cls) {
        case 'warrior':  return 'ì „ì‚¬';
        case 'knight':   return 'ê¸°ì‚¬';
        case 'archer':   return 'ê¶ìˆ˜';
        case 'monk':     return 'ìˆ˜ë„ì‚¬';
        case 'mage':     return 'ë§ˆë²•ì‚¬';
        case 'rogue':    return 'ë„ì ';
        case 'guardian': return 'ìˆ˜í˜¸ì';
        default:         return 'ëª¨í—˜ê°€';
      }
    }

    function createHero(name, cls) {
      const hero = {
        name,
        cls,
        baseMaxHp: randInt(28, 36),
        baseAtk: randInt(5, 8),
        baseDef: randInt(2, 5),
        hp: 0,
        equipment: {
          head: null, chest: null, arms: null, legs: null, boots: null,
          ring1: null, ring2: null, necklace: null, mainHand: null, offHand: null
        },
        tempAtk: 0,
        tempDef: 0,
        buffTurns: 0,
        status: { poison: 0 }
      };
      hero.hp = hero.baseMaxHp;
      return hero;
    }

    function calcHeroStats(hero) {
      let atk = hero.baseAtk;
      let def = hero.baseDef;
      let maxHp = hero.baseMaxHp;
      const eq = hero.equipment;

      for (const k in eq) {
        const item = eq[k];
        if (!item) continue;
        atk += item.attack || 0;
        def += item.defense || 0;
        maxHp += item.hp || 0;
      }

      // ì§ì—… ë³´ì •
      switch (hero.cls) {
        case 'warrior':  atk += 1; def += 1; break;
        case 'knight':   atk += 1; def += 2; maxHp += 4; break;
        case 'archer':   atk += 2; break;
        case 'monk':     maxHp += 6; break;
        case 'mage':     atk += 3; def -= 1; break;
        case 'rogue':    atk += 1; break;
        case 'guardian': def += 3; maxHp += 8; break;
      }

      atk += hero.tempAtk;
      def += hero.tempDef;
      if (def < 0) def = 0;
      return { atk, def, maxHp };
    }

    function anyHeroAlive() {
      return party.some(h => h.hp > 0);
    }
    function hasRogueAlive() {
      return party.some(h => h.hp > 0 && h.cls === 'rogue');
    }

    // ===== ì•„ì´í…œ/ì¥ë¹„ =====
    let nextItemId = 1;
    const rarityOrder = ['normal', 'magic', 'rare', 'unique', 'legend', 'epic'];
    function rarityIndex(r) { return rarityOrder.indexOf(r); }

    function rarityLabel(r) {
      switch (r) {
        case 'normal': return 'ì¼ë°˜';
        case 'magic':  return 'ë§¤ì§';
        case 'rare':   return 'ë ˆì–´';
        case 'unique': return 'ìœ ë‹ˆí¬';
        case 'legend': return 'ë ˆì „ë“œ';
        case 'epic':   return 'ì—í”½';
      }
      return r;
    }
    function rarityClass(r) { return 'rarity-' + r; }

    function slotShortIcon(slotType) {
      switch (slotType) {
        case 'head':     return 'ğŸª–';
        case 'chest':    return 'ğŸ›¡ï¸';
        case 'arms':     return 'ğŸ§¤';
        case 'legs':     return 'ğŸ‘–';
        case 'boots':    return 'ğŸ¥¾';
        case 'ring':     return 'ğŸ’';
        case 'necklace': return 'ğŸ“¿';
        case 'mainHand': return 'âš”ï¸';
        case 'offHand':  return 'ğŸ›¡ï¸';
        case 'potion':   return 'ğŸ§ª';
        case 'scroll':   return 'ğŸ“œ';
        default:         return ' ';
      }
    }

    function slotLabel(slotType) {
      switch (slotType) {
        case 'head':     return 'ğŸª– ë¨¸ë¦¬';
        case 'chest':    return 'ğŸ›¡ï¸ ëª¸í†µ';
        case 'arms':     return 'ğŸ§¤ íŒ”';
        case 'legs':     return 'ğŸ‘– ë‹¤ë¦¬';
        case 'boots':    return 'ğŸ¥¾ ì‹ ë°œ';
        case 'ring':     return 'ğŸ’ ë°˜ì§€';
        case 'necklace': return 'ğŸ“¿ ëª©ê±¸ì´';
        case 'mainHand': return 'âš”ï¸ ë¬´ê¸°';
        case 'offHand':  return 'ğŸ›¡ï¸ ë³´ì¡°ì†';
        case 'potion':   return 'ğŸ§ª ë¬¼ì•½';
        case 'scroll':   return 'ğŸ“œ ìŠ¤í¬ë¡¤';
        default:         return slotType;
      }
    }

    function createPotion() {
      return {
        id: nextItemId++,
        category: 'potion',
        type: 'heal',
        name: 'ì¹˜ìœ  ë¬¼ì•½',
        slotType: 'potion',
        description: 'ì„ íƒëœ ì•„êµ°ì˜ HPë¥¼ í¬ê²Œ íšŒë³µí•©ë‹ˆë‹¤.',
        price: 25
      };
    }

    function createScroll() {
      const kind = Math.random() < 0.5 ? 'fireball' : 'shock';
      if (kind === 'fireball') {
        return {
          id: nextItemId++,
          category: 'scroll',
          type: 'fireball',
          name: 'í™”ì—¼êµ¬ ìŠ¤í¬ë¡¤',
          slotType: 'scroll',
          description: 'ì£¼ë³€ ì ë“¤ì—ê²Œ í™”ì—¼ í”¼í•´ë¥¼ ì¤ë‹ˆë‹¤.',
          price: 40
        };
      } else {
        return {
          id: nextItemId++,
          category: 'scroll',
          type: 'shock',
          name: 'ê¸°ì ˆ ìŠ¤í¬ë¡¤',
          slotType: 'scroll',
          description: 'ëª¬ìŠ¤í„°ë¥¼ ì ì‹œ ë©í•˜ê²Œ ë§Œë“¤ì–´ ê³µê²©ì„ ì•½í™”í•©ë‹ˆë‹¤.',
          price: 35
        };
      }
    }

    function createBaseItemForSlot(slot) {
      switch (slot) {
        case 'head':     return { name: 'ê°€ì£½ íˆ¬êµ¬',   attack: 0, defense: 2, hp: 5 };
        case 'chest':    return { name: 'ê°€ì£½ ê°‘ì˜·',   attack: 0, defense: 4, hp:10 };
        case 'arms':     return { name: 'ê°€ì£½ ì¥ê°‘',   attack: 1, defense: 1, hp: 3 };
        case 'legs':     return { name: 'ê°€ì£½ ë°”ì§€',   attack: 0, defense: 3, hp: 6 };
        case 'boots':    return { name: 'ê°€ì£½ ë¶€ì¸ ',   attack: 0, defense: 2, hp: 4 };
        case 'ring':     return { name: 'êµ¬ë¦¬ ë°˜ì§€',   attack: 1, defense: 0, hp: 2 };
        case 'necklace': return { name: 'ë‚¡ì€ ëª©ê±¸ì´', attack: 0, defense: 0, hp: 8 };
        case 'mainHand': return { name: 'ì‡ ê²€',       attack: 6, defense: 0, hp: 0 };
        case 'offHand':  return { name: 'ë‚˜ë¬´ ë°©íŒ¨',   attack: 0, defense: 3, hp: 0 };
      }
      return { name: 'ì´ìƒí•œ ë¬¼ê±´', attack: 1, defense: 1, hp: 1 };
    }

    function makeItemName(baseName, rarity) {
      const prefix = {
        magic:  ['ë¹›ë‚˜ëŠ”', 'ë‚ ì¹´ë¡œìš´', 'íŠ¼íŠ¼í•œ', 'ì‹ ë¹„í•œ'],
        rare:   ['ì •ì˜ˆì˜', 'ê³ ê¸‰', 'ê°•í™”ëœ', 'ìˆ™ë ¨ìì˜'],
        unique: ['ê¸°ë¬˜í•œ', 'ê³ ëŒ€ì˜', 'ì €ì£¼ë°›ì€', 'íŠ¹ì´í•œ'],
        legend: ['ì „ì„¤ì˜', 'ì˜ì›…ì˜', 'ì™•ê°€ì˜', 'ì‹ ì„±í•œ'],
        epic:   ['ì—í”½', 'ì°¨ì›ì˜', 'ìš´ëª…ì˜', 'ê¶ê·¹ì˜']
      };
      if (rarity === 'normal') return baseName;
      const list = prefix[rarity] || [];
      if (!list.length) return baseName;
      const p = list[randInt(0, list.length - 1)];
      return p + ' ' + baseName;
    }

    function rollRarity(isBoss) {
      let r = Math.random();
      if (hasRelic('lucky')) r = Math.max(0, r - 0.08);

      if (!isBoss) {
        if (r < 0.60) return 'normal';
        if (r < 0.85) return 'magic';
        if (r < 0.97) return 'rare';
        return 'unique';
      } else {
        if (r < 0.20) return 'normal';
        if (r < 0.50) return 'magic';
        if (r < 0.75) return 'rare';
        if (r < 0.90) return 'unique';
        if (r < 0.97) return 'legend';
        return 'epic';
      }
    }

    function generateRandomItem(isBoss = false) {
      const roll = Math.random();
      if (!isBoss && roll < 0.18) return createPotion();
      if (!isBoss && roll < 0.30) return createScroll();

      const slots = ['head','chest','arms','legs','boots','ring','necklace','mainHand','offHand'];
      const slot = slots[randInt(0, slots.length - 1)];
      const rarity = rollRarity(isBoss);
      const base = createBaseItemForSlot(slot);

      let atk = base.attack, def = base.defense, hp = base.hp;
      let mul = 1;
      switch (rarity) {
        case 'normal': mul = 1.0; break;
        case 'magic':  mul = 1.2; break;
        case 'rare':   mul = 1.5; break;
        case 'unique': mul = 1.8; break;
        case 'legend': mul = 2.2; break;
        case 'epic':   mul = 2.7; break;
      }
      atk = Math.round(atk * mul) + randInt(0,2);
      def = Math.round(def * mul) + randInt(0,2);
      hp  = Math.round(hp  * mul) + randInt(0,4);

      return {
        id: nextItemId++,
        category: 'gear',
        name: makeItemName(base.name, rarity),
        slotType: slot,
        rarity,
        attack: atk,
        defense: def,
        hp,
        price: (atk + def + Math.floor(hp/2)) * 3 + randInt(5,20)
      };
    }

    function itemSummary(item) {
      if (item.category === 'gear') {
        const parts = [];
        if (item.attack) parts.push(`ATK+${item.attack}`);
        if (item.defense) parts.push(`DEF+${item.defense}`);
        if (item.hp)      parts.push(`HP+${item.hp}`);
        return parts.join(', ');
      } else if (item.category === 'potion') {
        return 'HP íšŒë³µ';
      } else if (item.category === 'scroll') {
        return item.type === 'fireball' ? 'ì£¼ë³€ ì  í™”ì—¼ í”¼í•´' : 'ì  ê³µê²© ì•½í™”';
      }
      return '';
    }

    function equipOrUseItem(index) {
      const item = inventory[index];
      if (!item) return;

      if (item.category === 'potion') { usePotion(index); return; }
      if (item.category === 'scroll') { useScroll(index); return; }
      equipItem(index);
    }

    function equipItem(idx) {
      if (!party.length) return;
      const hero = party[selectedHeroIndex];
      const item = inventory[idx];
      if (!item || item.category !== 'gear') return;

      let slotKey = null;
      if (item.slotType === 'ring') {
        if (!hero.equipment.ring1) slotKey = 'ring1';
        else if (!hero.equipment.ring2) slotKey = 'ring2';
        else slotKey = 'ring1';
      } else slotKey = item.slotType;

      const old = hero.equipment[slotKey];
      hero.equipment[slotKey] = item;

      const stats = calcHeroStats(hero);
      if (hero.hp > stats.maxHp) hero.hp = stats.maxHp;

      let msg;
      if (old) {
        inventory[idx] = old;
        msg = `${hero.name}ê°€ ${old.name}ì„(ë¥¼) ${item.name}ìœ¼ë¡œ êµì²´í–ˆìŠµë‹ˆë‹¤.`;
      } else {
        inventory.splice(idx, 1);
        msg = `${hero.name}ê°€ ${item.name}ì„(ë¥¼) ì¥ë¹„í–ˆìŠµë‹ˆë‹¤.`;
      }

      if (mode === 'dungeon') {
        msg += ' (1í„´ ê²½ê³¼)';
        setLog(msg);
        monstersAct();
      } else setLog(msg);

      renderAll();
    }

    function unequipSlot(slotKey) {
      if (!party.length) return;
      const hero = party[selectedHeroIndex];
      const item = hero.equipment[slotKey];
      if (!item) {
        setLog('í•´ë‹¹ ìŠ¬ë¡¯ì— ì¥ë¹„ê°€ ì—†ìŠµë‹ˆë‹¤.');
        renderAll();
        return;
      }
      hero.equipment[slotKey] = null;
      inventory.push(item);
      const stats = calcHeroStats(hero);
      if (hero.hp > stats.maxHp) hero.hp = stats.maxHp;

      let msg = `${hero.name}ê°€ ${item.name}ì„(ë¥¼) ë²—ì—ˆìŠµë‹ˆë‹¤.`;
      if (mode === 'dungeon') {
        msg += ' (1í„´ ê²½ê³¼)';
        setLog(msg);
        monstersAct();
      } else setLog(msg);

      renderAll();
    }

    function sellItem(idx) {
      if (mode !== 'town') {
        setLog('ë˜ì „ ë‚´ë¶€ì—ì„œëŠ” ì•„ì´í…œì„ íŒë§¤í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        renderAll();
        return;
      }
      const item = inventory[idx];
      if (!item) return;
      const price = Math.max(5, Math.floor((item.price || 20) * 0.6));
      gold += price;
      inventory.splice(idx, 1);
      setLog(`${item.name}ì„(ë¥¼) ${price} ê³¨ë“œì— íŒë§¤í–ˆìŠµë‹ˆë‹¤.`);
      renderAll();
    }

    function usePotion(idx) {
      if (!party.length) return;
      const item = inventory[idx];
      const hero = party[selectedHeroIndex];
      const stats = calcHeroStats(hero);
      const heal = clamp(Math.floor(stats.maxHp * 0.6), 1, stats.maxHp - hero.hp);
      if (heal <= 0) {
        setLog(`${hero.name}ì€(ëŠ”) ì´ë¯¸ ì²´ë ¥ì´ ê°€ë“í•©ë‹ˆë‹¤.`);
        renderAll();
        return;
      }
      hero.hp += heal;
      hero.status.poison = 0;
      inventory.splice(idx, 1);
      let msg = `${hero.name}ì´(ê°€) ${item.name}ì„(ë¥¼) ë§ˆì…¨ë‹¤. HP ${heal} íšŒë³µ (ì¤‘ë… í•´ì œ).`;
      if (mode === 'dungeon') {
        msg += ' (1í„´ ê²½ê³¼)';
        setLog(msg);
        monstersAct();
      } else setLog(msg);
      renderAll();
    }

    function useScroll(idx) {
      const item = inventory[idx];
      if (!item || item.category !== 'scroll') return;
      if (mode !== 'dungeon') {
        setLog('ìŠ¤í¬ë¡¤ì€ ë˜ì „ì—ì„œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
        renderAll();
        return;
      }
      inventory.splice(idx, 1);

      if (item.type === 'fireball') {
        let hit = 0;
        for (let i = monsters.length - 1; i >= 0; i--) {
          const m = monsters[i];
          const dist = Math.abs(m.x - playerX) + Math.abs(m.y - playerY);
          if (dist <= 2) {
            let baseMin = 12 + floor;
            let baseMax = 20 + floor * 2;
            if (hasRelic('focus')) {
              baseMin = Math.floor(baseMin * 1.4);
              baseMax = Math.floor(baseMax * 1.4);
            }
            const dmg = randInt(baseMin, baseMax);
            m.hp -= dmg;
            appendLog(`í™”ì—¼êµ¬ê°€ ${monsterLabel(m)}ì—ê²Œ ${dmg} í”¼í•´!`);
            if (m.hp <= 0) {
              m.hp = 0;
              appendLog(`${monsterLabel(m)} ê²©íŒŒ!`);
              onMonsterKilled(i, m);
            }
            hit++;
          }
        }
        if (!hit) setLog('í™”ì—¼êµ¬ë¥¼ ì‚¬ìš©í–ˆì§€ë§Œ ì£¼ë³€ì— ì ì´ ì—†ë‹¤.');
        else setLog('í™”ì—¼êµ¬ ìŠ¤í¬ë¡¤ì„ ì‚¬ìš©í–ˆë‹¤!');
      } else if (item.type === 'shock') {
        for (const m of monsters) {
          m.shockTurns = (m.shockTurns || 0) + 3;
        }
        setLog('ëª¨ë“  ëª¬ìŠ¤í„°ê°€ ì ì‹œ ë©í•´ì¡Œë‹¤! (ëª‡ í„´ ë™ì•ˆ ê³µê²© ì•½í™”)');
      }
      monstersAct();
      renderAll();
    }

    // ===== ë¡œê·¸ =====
    const logEl = document.getElementById('log');
    function setLog(msg) {
      logEl.textContent = msg;
      logEl.scrollTop = logEl.scrollHeight;
    }
    function appendLog(msg) {
      logEl.textContent += '\n' + msg;
      logEl.scrollTop = logEl.scrollHeight;
    }

    // ===== ë˜ì „ ìƒì„± =====
    function createEmptyMap() {
      dungeonMap = [];
      visible = [];
      explored = [];
      for (let y=0; y<MAP_H; y++) {
        const row = [], vRow = [], eRow = [];
        for (let x=0; x<MAP_W; x++) {
          row.push(TILE_WALL);
          vRow.push(false);
          eRow.push(false);
        }
        dungeonMap.push(row);
        visible.push(vRow);
        explored.push(eRow);
      }
    }

    function rectsOverlap(a,b) {
      return !(a.x + a.w <= b.x || b.x + b.w <= a.x || a.y + a.h <= b.y || b.y + b.h <= a.y);
    }

    function carveRoom(room) {
      for (let y=room.y; y<room.y+room.h; y++) {
        for (let x=room.x; x<room.x+room.w; x++) {
          if (x>0 && x<MAP_W-1 && y>0 && y<MAP_H-1) {
            dungeonMap[y][x] = TILE_FLOOR;
          }
        }
      }
    }

    function carveHTunnel(x1,x2,y) {
      for (let x=Math.min(x1,x2); x<=Math.max(x1,x2); x++) {
        if (x>0 && x<MAP_W-1 && y>0 && y<MAP_H-1) {
          dungeonMap[y][x] = TILE_FLOOR;
        }
      }
    }

    function carveVTunnel(y1,y2,x) {
      for (let y=Math.min(y1,y2); y<=Math.max(y1,y2); y++) {
        if (x>0 && x<MAP_W-1 && y>0 && y<MAP_H-1) {
          dungeonMap[y][x] = TILE_FLOOR;
        }
      }
    }

    function generateDungeon() {
      createEmptyMap();
      monsters = [];
      chests = [];
      traps = [];
      altars = [];
      campfires = [];
      merchants = [];
      bossAlive = false;
      exitOpen = false;

      const rooms = [];
      for (let i=0; i<MAX_ROOMS; i++) {
        const w = randInt(6,12);
        const h = randInt(4,8);
        const x = randInt(1, MAP_W - w - 2);
        const y = randInt(1, MAP_H - h - 2);
        const room = {x,y,w,h};
        let ok = true;
        for (const other of rooms) {
          if (rectsOverlap(room, other)) { ok = false; break; }
        }
        if (!ok) continue;
        carveRoom(room);
        if (rooms.length) {
          const prev = rooms[rooms.length-1];
          const px = prev.x + Math.floor(prev.w/2);
          const py = prev.y + Math.floor(prev.h/2);
          const cx = room.x + Math.floor(room.w/2);
          const cy = room.y + Math.floor(room.h/2);
          if (Math.random()<0.5) {
            carveHTunnel(px,cx,py);
            carveVTunnel(py,cy,cx);
          } else {
            carveVTunnel(py,cy,px);
            carveHTunnel(px,cx,cy);
          }
        }
        rooms.push(room);
      }

      // í”Œë ˆì´ì–´ ì‹œì‘ ìœ„ì¹˜
      const first = rooms[0];
      playerX = first.x + Math.floor(first.w/2);
      playerY = first.y + Math.floor(first.h/2);
      partyPositions = party.map((_,idx) => ({x: playerX - idx -1, y: playerY}));

      // ê³„ë‹¨/ë³´ìŠ¤ ìœ„ì¹˜
      const last = rooms[rooms.length-1];
      const sx = last.x + Math.floor(last.w/2);
      const sy = last.y + Math.floor(last.h/2);
      dungeonMap[sy][sx] = TILE_STAIRS;

      // ëª¬ìŠ¤í„° ë°°ì¹˜
      const baseMon = 6 + Math.floor(floor/3);
      const monsterCount = clamp(baseMon, 5, 20);
      for (let i=0; i<monsterCount; i++) {
        let placed=false; let tries=0;
        while (!placed && tries<100) {
          const room = rooms[randInt(0, rooms.length-1)];
          const x = randInt(room.x, room.x+room.w-1);
          const y = randInt(room.y, room.y+room.h-1);
          if (dungeonMap[y][x] !== TILE_FLOOR) { tries++; continue; }
          if (x===playerX && y===playerY) { tries++; continue; }
          if (monsters.some(m => m.x===x && m.y===y)) { tries++; continue; }

          let type;
          if (floor === 100) type = DEMON_LORD;
          else if (floor %5 ===0 && !bossAlive) type = BOSS_TYPES[randInt(0,BOSS_TYPES.length-1)];
          else type = MONSTER_TYPES[randInt(0,MONSTER_TYPES.length-1)];

          const levelScale = 1 + floor*0.08;
          const hp = Math.floor(20 * type.hpMul * levelScale);
          const atk = Math.floor(6 * type.atkMul * levelScale);
          const def = Math.floor(3 * type.defMul * levelScale);

          monsters.push({
            x,y,
            typeId: type.id,
            name: type.name,
            emoji: type.emoji,
            hp,
            atk,
            def,
            isBoss: (type === DEMON_LORD || floor%5===0 && !bossAlive)
          });
          if (monsters[monsters.length-1].isBoss) bossAlive = true;
          placed=true;
        }
      }

      // ë³´ë¬¼ìƒì/í•¨ì •/ì œë‹¨/ìº í”„/ìƒì¸
      const floorFactor = 1 + floor*0.03;
      const chestCount = clamp(Math.floor(3 * floorFactor/2), 2, 10);
      for (let i=0;i<chestCount;i++) placeFeatureRandom(TILE_CHEST, chests);
      const trapCount = clamp(Math.floor(4 * floorFactor/2), 3, 12);
      for (let i=0;i<trapCount;i++) placeFeatureRandom(TILE_TRAP, traps);
      const altarCount = randInt(0,2);
      for (let i=0;i<altarCount;i++) placeFeatureRandom(TILE_ALTAR, altars);
      const campCount = randInt(0,2);
      for (let i=0;i<campCount;i++) placeFeatureRandom(TILE_CAMP, campfires);
      const merchCount = randInt(0,1);
      for (let i=0;i<merchCount;i++) placeFeatureRandom(TILE_MERCH, merchants);

      recomputeFov();
    }

    function placeFeatureRandom(tile, list) {
      let placed=false; let tries=0;
      while(!placed && tries<200) {
        const x = randInt(1,MAP_W-2);
        const y = randInt(1,MAP_H-2);
        if (dungeonMap[y][x]!==TILE_FLOOR) { tries++; continue; }
        if (x===playerX && y===playerY) { tries++; continue; }
        if (monsters.some(m => m.x===x && m.y===y)) { tries++; continue; }
        dungeonMap[y][x] = tile;
        if (list) list.push({x,y, triggered:false});
        placed=true;
      }
    }

    // ===== FOV & ê·¸ë¦¬ê¸° =====
    function getFovRadius() {
      let r = BASE_FOV_RADIUS;
      if (hasRelic('lantern')) r++;
      return r;
    }

    function recomputeFov() {
      const r = getFovRadius();
      for (let y=0;y<MAP_H;y++) for (let x=0;x<MAP_W;x++) visible[y][x]=false;
      for (let dy=-r; dy<=r; dy++) {
        for (let dx=-r; dx<=r; dx++) {
          const x = playerX + dx;
          const y = playerY + dy;
          if (x<0||x>=MAP_W||y<0||y>=MAP_H) continue;
          const dist = Math.abs(dx)+Math.abs(dy);
          if (dist<=r) {
            visible[y][x]=true;
            explored[y][x]=true;
          }
        }
      }
    }

    function monsterLabel(m) {
      return `${m.name}`;
    }

    function drawDungeon() {
      const screen = document.getElementById('screen');
      let html = '';

      const halfW = Math.floor(VIEW_W/2);
      const halfH = Math.floor(VIEW_H/2);

      const startX = clamp(playerX - halfW, 0, MAP_W - VIEW_W);
      const startY = clamp(playerY - halfH, 0, MAP_H - VIEW_H);

      for (let y=startY; y<startY+VIEW_H; y++) {
        for (let x=startX; x<startX+VIEW_W; x++) {
          let ch = ' ';
          const tile = dungeonMap[y][x];
          const vis = visible[y][x];
          const exp = explored[y][x];

          // íŒŒí‹° ìœ„ì¹˜
          let partyIndex = partyPositions.findIndex(p => p.x===x && p.y===y);
          if (partyIndex === 0 && vis) {
            ch = heroEmoji(party[0]);
          } else if (partyIndex > 0 && vis) {
            ch = heroEmoji(party[partyIndex]);
          } else {
            // ëª¬ìŠ¤í„°
            const m = monsters.find(m => m.x===x && m.y===y);
            if (m && vis) ch = m.emoji;
            else if (vis) {
              if (tile === TILE_WALL) ch = 'â¬›';
              else if (tile === TILE_FLOOR) ch = 'â¬œ';
              else if (tile === TILE_STAIRS) ch = 'ğŸ”½';
              else if (tile === TILE_CHEST) ch = 'ğŸ’°';
              else if (tile === TILE_TRAP) {
                const isKnown = hasRogueAlive() || traps.some(t => t.x===x && t.y===y && t.triggered);
                ch = isKnown ? 'âš ï¸' : 'â¬œ';
              }
              else if (tile === TILE_ALTAR) ch = 'â›©ï¸';
              else if (tile === TILE_CAMP) ch = 'ğŸ”¥';
              else if (tile === TILE_MERCH) ch = 'ğŸ§™â€â™‚ï¸';
              else ch = 'â¬œ';
            } else if (exp) {
              if (tile === TILE_WALL) ch = 'â–ªï¸';
              else ch = 'â–«ï¸';
            } else {
              ch = ' ';
            }
          }
          html += `<span class="tile">${ch}</span>`;
        }
        html += '\n';
      }
      screen.innerHTML = html;
    }

    function drawTown() {
      const screen = document.getElementById('screen');
      const imgHtml = `
<div class="town-buttons">
  <button onclick="hireAlly()">ë™ë£Œ ëª¨ì§‘ (50G)</button>
  <button onclick="restInTown()">íœ´ì‹ (ì „ì› íšŒë³µ)</button>
  <button onclick="enterDungeon()">ë˜ì „ ì…ì¥</button>
</div>
<div class="town-wrapper">
  <img class="town-img" src="/mnt/data/e7399df4-040f-44b6-8f6f-fbc204fe16f1.png" alt="ë§ˆì„ í’ê²½" />
</div>
ë§ˆì„ ê´‘ì¥ì…ë‹ˆë‹¤. ì—¬ê´€ì—ì„œ ë™ë£Œë¥¼ ëª¨ì§‘í•˜ê³ , ìƒì ì—ì„œ ì¥ë¹„ì™€ ì†Œëª¨í’ˆì„ êµ¬ì…í•œ ë’¤
ê¹Šì€ ë˜ì „ì— ë„ì „í•´ ë³´ì„¸ìš”.\n\nê³¨ë“œ: ${gold}  |  í˜„ì¬ ì¸µ ê¸°ë¡: ${floor}ì¸µê¹Œì§€ íƒí—˜`;
      screen.textContent = '';
      screen.innerHTML = imgHtml;
    }

    // ===== ì „íˆ¬ ë° ì´ë™ =====
    function movePlayer(dx,dy) {
      if (mode!=='dungeon') return;
      const nx = playerX + dx;
      const ny = playerY + dy;
      if (nx<0||nx>=MAP_W||ny<0||ny>=MAP_H) return;

      const tile = dungeonMap[ny][nx];

      // ë²½
      if (tile === TILE_WALL) {
        setLog('ë‹¨ë‹¨í•œ ë²½ì´ë‹¤.');
        renderAll();
        return;
      }

      // ëª¬ìŠ¤í„°
      const mIndex = monsters.findIndex(m => m.x===nx && m.y===ny);
      if (mIndex >= 0) {
        battle(monsters[mIndex], mIndex);
        return;
      }

      // ì´ë™
      playerX = nx; playerY = ny;
      // íŒŒí‹° ê¼¬ë¦¬ ì´ë™
      for (let i=partyPositions.length-1; i>0; i--) {
        partyPositions[i].x = partyPositions[i-1].x;
        partyPositions[i].y = partyPositions[i-1].y;
      }
      partyPositions[0].x = playerX;
      partyPositions[0].y = playerY;

      handleTileEvent(tile, nx, ny);

      turnCount++;
      recomputeFov();
      monstersAct();
      renderAll();
    }

    function handleTileEvent(tile,x,y) {
      if (tile === TILE_STAIRS) {
        // 100ì¸µì€ ì—¬ê¸°ì„œ ë‚´ë ¤ê°ˆ ìˆ˜ ì—†ìŒ (ë§ˆì™• ì²˜ì¹˜ ì‹œ ìë™ ì—”ë”©)
        if (floor === 100) {
          setLog('ê°•ë ¥í•œ ë§ˆì™•ì˜ ê¸°ìš´ìœ¼ë¡œ ê³„ë‹¨ì´ ë´‰ì¸ë¼ ìˆë‹¤.');
          renderAll();
          return;
        }

        // ì¼ë°˜ ì¸µ (5ì˜ ë°°ìˆ˜ ì•„ë‹˜): ë°”ë¡œ ë‹¤ìŒ ì¸µìœ¼ë¡œ
        if (floor % 5 !== 0) {
          floor++;
          setLog(`${floor}ì¸µìœ¼ë¡œ ë‚´ë ¤ê°‘ë‹ˆë‹¤...`);
          generateDungeon();
          renderAll();
          return;
        }

        // ë³´ìŠ¤ì¸µ: ë³´ìŠ¤ ì²˜ì¹˜ ì „ì´ë©´ ë´‰ì¸
        if (!exitOpen) {
          setLog('ê³„ë‹¨ì´ ë´‰ì¸ë¼ ìˆë‹¤. ë³´ìŠ¤ë¥¼ ë¨¼ì € ì“°ëŸ¬ëœ¨ë¦¬ì.');
          renderAll();
          return;
        }

        // ë³´ìŠ¤ ì²˜ì¹˜ í›„: ë‚´ë ¤ê°ˆì§€, íƒˆì¶œí• ì§€ ì„ íƒ
        const goDown = confirm('ë³´ìŠ¤ë¥¼ ì“°ëŸ¬ëœ¨ë¦¬ê³  ê³„ë‹¨ì´ ì—´ë ¸ë‹¤.\n\n[í™•ì¸] ë” ê¹Šì€ ì¸µìœ¼ë¡œ ë‚´ë ¤ê°„ë‹¤.\n[ì·¨ì†Œ] ì—¬ê¸°ì„œ íƒˆì¶œí•´ ë§ˆì„ë¡œ ëŒì•„ê°„ë‹¤.');
        if (goDown) {
          floor++;
          setLog(`${floor}ì¸µìœ¼ë¡œ ë‚´ë ¤ê°‘ë‹ˆë‹¤...`);
          generateDungeon();
        } else {
          returnToTown(true);
        }
        renderAll();
        return;
      }

      if (tile === TILE_CHEST) {
        dungeonMap[y][x] = TILE_FLOOR;
        const goldGain = randInt(20,60);
        gold += goldGain;
        appendLog(`ë³´ë¬¼ìƒìë¥¼ ì—´ì—ˆë‹¤! ê³¨ë“œ ${goldGain} íšë“.`);
        const itemChance = Math.random();
        if (itemChance < 0.9) {
          const item = generateRandomItem(false);
          inventory.push(item);
          appendLog(`[ìƒì] ${item.name} íšë“.`);
        }
      } else if (tile === TILE_TRAP) {
        let trapObj = traps.find(t => t.x===x && t.y===y);
        if (trapObj && !trapObj.triggered) {
          trapObj.triggered = true;
          const victims = party.filter(h => h.hp>0);
          if (victims.length) {
            const target = victims[randInt(0, victims.length-1)];
            const dmg = randInt(4,10) + Math.floor(floor/3);
            target.hp -= dmg;
            appendLog(`í•¨ì •ì„ ë°Ÿì•˜ë‹¤! ${target.name}ì´(ê°€) ${dmg} í”¼í•´ë¥¼ ì…ì—ˆë‹¤.`);
            if (target.hp <=0) {
              target.hp = 0;
              appendLog(`${target.name}ì´(ê°€) ì“°ëŸ¬ì¡Œë‹¤...`);
              if (!anyHeroAlive()) {
                handlePartyWipe();
                return;
              }
            }
          }
        }
      } else if (tile === TILE_ALTAR) {
        altarEvent(x,y);
      } else if (tile === TILE_CAMP) {
        campEvent(x,y);
      } else if (tile === TILE_MERCH) {
        merchantEvent(x,y);
      }
    }

    function altarEvent(x,y) {
      dungeonMap[y][x] = TILE_FLOOR;
      const roll = Math.random();
      if (roll < 0.4) {
        for (const h of party) {
          if (h.hp<=0) continue;
          const stats = calcHeroStats(h);
          h.hp = stats.maxHp;
        }
        appendLog('ì¶•ë³µì˜ ì œë‹¨ì´ë‹¤! íŒŒí‹° ì „ì›ì´ ì™„ì „íˆ íšŒë³µëë‹¤.');
      } else if (roll < 0.8) {
        for (const h of party) {
          if (h.hp<=0) continue;
          h.tempAtk += 2;
          h.tempDef += 2;
          h.buffTurns = Math.max(h.buffTurns, 20);
        }
        appendLog('ì œë‹¨ì—ì„œ í˜ì´ ì†Ÿì•„ë‚œë‹¤! 20í„´ ë™ì•ˆ ATK/DEF +2.');
      } else {
        for (const h of party) {
          if (h.hp<=0) continue;
          h.status.poison += 10;
        }
        appendLog('ì œë‹¨ì´ ê°‘ìê¸° ì–´ë‘ì›Œì§€ë”ë‹ˆ, íŒŒí‹°ê°€ ì €ì£¼ë¥¼ ë°›ì•˜ë‹¤... (10í„´ ë™ì•ˆ ì´ë™ ì‹œ ì¤‘ë… í”¼í•´)');
      }
    }

    function campEvent(x,y) {
      dungeonMap[y][x] = TILE_FLOOR;
      const heal = Math.random() < 0.5;
      if (heal) {
        for (const h of party) {
          if (h.hp<=0) continue;
          const stats = calcHeroStats(h);
          const gain = Math.floor(stats.maxHp * 0.4);
          h.hp = Math.min(stats.maxHp, h.hp + gain);
        }
        appendLog('ëª¨ë‹¥ë¶ˆ ê³ì—ì„œ ì ì‹œ ì‰°ë‹¤. íŒŒí‹°ì˜ ì²´ë ¥ì´ ì•½ê°„ íšŒë³µëë‹¤.');
      } else {
        appendLog('ì‹ëŸ‰ì´ ë‚˜ë¹ ì¡Œë‹¤... ì•„ë¬´ ì¼ë„ ì¼ì–´ë‚˜ì§€ ì•Šì•˜ë‹¤.');
      }
    }

    function merchantEvent(x,y) {
      dungeonMap[y][x] = TILE_FLOOR;
      const item = generateRandomItem(true);
      inventory.push(item);
      appendLog(`ìˆ˜ìƒí•œ ë– ëŒì´ ìƒì¸ì´ ì¥ë¹„ í•˜ë‚˜ë¥¼ ê±´ë„¨ ë’¤ ì‚¬ë¼ì¡Œë‹¤.\n[íšë“] ${item.name}`);
    }

    function battle(monster, index) {
      if (!anyHeroAlive()) return;
      // íŒŒí‹° ê³µê²©
      let totalDamage = 0;
      for (const h of party) {
        if (h.hp<=0) continue;
        const stats = calcHeroStats(h);
        let atk = stats.atk + randInt(-1,2);
        if (atk<1) atk=1;
        if (h.cls==='archer' && Math.abs(monster.x-playerX)+Math.abs(monster.y-playerY)>1) {
          atk += 2;
        }
        if (h.cls==='rogue' && Math.random()<0.15) {
          atk *= 2;
          appendLog(`${h.name}ì˜ ê¸°ìŠµ ê³µê²©! (ì¹˜ëª…íƒ€)`);
        }
        const dmg = Math.max(1, atk - monster.def);
        monster.hp -= dmg;
        totalDamage += dmg;
      }
      setLog(`íŒŒí‹°ê°€ ${monsterLabel(monster)}ì—ê²Œ ì´ ${totalDamage} í”¼í•´ë¥¼ ì…í˜”ë‹¤.`);
      if (monster.hp <= 0) {
        monster.hp = 0;
        appendLog(`${monsterLabel(monster)}ë¥¼ ì“°ëŸ¬ëœ¨ë ¸ë‹¤!`);
        onMonsterKilled(index, monster);
        recomputeFov();
        renderAll();
        return;
      }

      // ëª¬ìŠ¤í„° ë°˜ê²©
      const targets = party.filter(h => h.hp>0);
      if (!targets.length) return;
      let target = targets[randInt(0, targets.length-1)];

      let atk = monster.atk + randInt(-1,2);
      if (monster.shockTurns && monster.shockTurns>0) atk = Math.floor(atk*0.5);
      const stats = calcHeroStats(target);
      let dmg = Math.max(1, atk - stats.def);
      target.hp -= dmg;
      appendLog(`${monsterLabel(monster)}ì˜ ë°˜ê²©! ${target.name}ì´(ê°€) ${dmg} í”¼í•´.`);

      if (target.hp<=0) {
        target.hp=0;
        appendLog(`${target.name}ì´(ê°€) ì“°ëŸ¬ì¡Œë‹¤...`);
        if (!anyHeroAlive()) {
          handlePartyWipe();
          return;
        }
      }

      monstersAct();
      recomputeFov();
      renderAll();
    }

    function applyRelicOnKill() {
      if (!hasRelic('blood')) return;
      for (const h of party) {
        if (h.hp<=0) continue;
        h.hp += 2;
        const stats = calcHeroStats(h);
        if (h.hp>stats.maxHp) h.hp = stats.maxHp;
      }
      appendLog('[ìœ ë¬¼] í”¼ì˜ ë¶€ì  íš¨ê³¼ë¡œ íŒŒí‹°ê°€ ì†ŒëŸ‰ íšŒë³µí–ˆë‹¤.');
    }

    function grantRandomRelic(reason) {
      const available = RELIC_POOL.filter(r => !hasRelic(r.id));
      if (!available.length) return;
      const relic = available[randInt(0, available.length-1)];
      relics.push(relic);
      appendLog(`[ìœ ë¬¼ íšë“] ${relic.name} - ${relic.desc}`);
    }

    function onMonsterKilled(index, monster) {
      const goldGain = randInt(5, 20) + Math.floor(floor/2);
      gold += goldGain;
      appendLog(`${monsterLabel(monster)}ì—ê²Œì„œ ${goldGain} ê³¨ë“œë¥¼ ì–»ì—ˆë‹¤.`);
      if (Math.random()<0.3 || monster.isBoss) {
        const item = generateRandomItem(monster.isBoss);
        inventory.push(item);
        appendLog(`[ë“œë] ${item.name} íšë“.`);
      }
      applyRelicOnKill();
      updateQuestsOnKill(monster);

      if (monster.isBoss) {
        bossAlive = false;
        if (floor === 100) {
          handleFinalBossDefeat();
        } else {
          exitOpen = true;
          appendLog('ë³´ìŠ¤ë¥¼ ì²˜ì¹˜í–ˆë‹¤! ê³„ë‹¨ì—ì„œ íƒˆì¶œí•˜ê±°ë‚˜ ë” ë‚´ë ¤ê°ˆ ìˆ˜ ìˆë‹¤.');
          grantRandomRelic('boss');
        }
      }

      monsters.splice(index,1);
    }

    function handleFinalBossDefeat() {
      setLog('ìµœì¢… ë³´ìŠ¤ ë§ˆì™•ì„ ì“°ëŸ¬ëœ¨ë ¸ë‹¤! 100ì¸µ ì •ë³µ ì™„ë£Œ!');
      gameCleared = true;
      grantRandomRelic('final');
      returnToTown(true);
    }

    function handlePartyWipe() {
      setLog('íŒŒí‹°ê°€ ì „ë©¸í–ˆë‹¤... ê°„ì‹ íˆ ëª©ìˆ¨ë§Œ ê±´ì ¸ ë§ˆì„ë¡œ ë„ë§ì³¤ë‹¤.');
      if (inventory.length>0) {
        const toLose = Math.floor(inventory.length/2);
        for (let i=0;i<toLose;i++) {
          const idx = randInt(0, inventory.length-1);
          inventory.splice(idx,1);
        }
        appendLog(`ì¶©ê²©ìœ¼ë¡œ ì¥ë¹„ ì¼ë¶€ë¥¼ ìƒì–´ë²„ë ¸ë‹¤... (ì¸ë²¤í† ë¦¬ ì•½ ì ˆë°˜ ì†ì‹¤)`);
      }
      if (gold>0) {
        const lost = Math.floor(gold*0.3);
        gold -= lost;
        appendLog(`ì†Œì§€ê¸ˆë„ í©ì–´ì¡Œë‹¤... ê³¨ë“œ ${lost} ì†ì‹¤.`);
      }

      for (const h of party) {
        const stats = calcHeroStats(h);
        h.hp = Math.max(1, Math.floor(stats.maxHp*0.3));
        h.status.poison = 0;
        h.buffTurns = 0;
        h.tempAtk = 0;
        h.tempDef = 0;
      }
      returnToTown(false);
    }

    function monstersAct() {
      for (const h of party) {
        if (h.buffTurns>0) {
          h.buffTurns--;
          if (h.buffTurns===0) {
            h.tempAtk = 0;
            h.tempDef = 0;
            appendLog(`${h.name}ì˜ ì œë‹¨ ë²„í”„ê°€ ì‚¬ë¼ì¡Œë‹¤.`);
          }
        }
        if (h.status.poison>0 && h.hp>0) {
          h.status.poison--;
          h.hp -= 1;
          if (h.hp<=0) {
            h.hp=0;
            appendLog(`${h.name}ì€(ëŠ”) ë…ìœ¼ë¡œ ì“°ëŸ¬ì¡Œë‹¤...`);
          }
        }
      }
      if (!anyHeroAlive()) {
        handlePartyWipe();
        return;
      }

      for (const m of monsters) {
        if (m.hp<=0) continue;
        if (m.shockTurns && m.shockTurns>0) m.shockTurns--;

        const dx = playerX - m.x;
        const dy = playerY - m.y;
        const dist = Math.abs(dx)+Math.abs(dy);

        if (dist === 1) {
          const targets = party.filter(h => h.hp>0);
          if (!targets.length) return;
          let target;
          if (dist===1 && party[0].hp>0) target = party[0];
          else target = targets[randInt(0,targets.length-1)];
          const stats = calcHeroStats(target);
          let atk = m.atk + randInt(-1,2);
          if (m.shockTurns && m.shockTurns>0) atk = Math.floor(atk*0.6);
          const dmg = Math.max(1, atk - stats.def);
          target.hp -= dmg;
          appendLog(`${monsterLabel(m)}ê°€ ${target.name}ì„(ë¥¼) ê³µê²©! (${dmg} í”¼í•´)`);
          if (target.hp<=0) {
            target.hp=0;
            appendLog(`${target.name}ì´(ê°€) ì“°ëŸ¬ì¡Œë‹¤...`);
            if (!anyHeroAlive()) {
              handlePartyWipe();
              return;
            }
          }
        } else if (dist <= 6) {
          const stepX = dx>0 ? 1 : (dx<0 ? -1 : 0);
          const stepY = dy>0 ? 1 : (dy<0 ? -1 : 0);
          const tryMoves = [];
          if (stepX!==0) tryMoves.push({x:m.x+stepX, y:m.y});
          if (stepY!==0) tryMoves.push({x:m.x, y:m.y+stepY});
          for (const mv of tryMoves) {
            if (mv.x<0||mv.x>=MAP_W||mv.y<0||mv.y>=MAP_H) continue;
            if (dungeonMap[mv.y][mv.x]===TILE_WALL) continue;
            if (monsters.some(o => o!==m && o.x===mv.x && o.y===mv.y)) continue;
            m.x = mv.x; m.y = mv.y;
            break;
          }
        } else {
          if (Math.random()<0.4) {
            const dir = [[1,0],[-1,0],[0,1],[0,-1]][randInt(0,3)];
            const tx = m.x + dir[0], ty = m.y + dir[1];
            if (tx>0 && tx<MAP_W-1 && ty>0 && ty<MAP_H-1 && dungeonMap[ty][tx]!==TILE_WALL &&
                !monsters.some(o => o!==m && o.x===tx && o.y===ty)) {
              m.x = tx; m.y = ty;
            }
          }
        }
      }
    }

    // ===== ë§ˆì„/ìƒì /ì˜ë¢° =====
    function restInTown() {
      if (!party.length) return;
      for (const h of party) {
        const stats = calcHeroStats(h);
        h.hp = stats.maxHp;
        h.status.poison = 0;
        h.buffTurns = 0;
        h.tempAtk = 0;
        h.tempDef = 0;
      }
      setLog('ì—¬ê´€ì—ì„œ í‘¹ ì‰¬ì—ˆë‹¤. íŒŒí‹° ì „ì›ì´ ì™„ì „íˆ íšŒë³µëë‹¤.');
      renderAll();
    }

    function hireAlly() {
      if (party.length>=4) {
        setLog('ì´ë¯¸ íŒŒí‹°ê°€ ê°€ë“ ì°¼ë‹¤. (ìµœëŒ€ 4ëª…)');
        renderAll();
        return;
      }
      const cost = 50;
      if (gold < cost) {
        setLog(`ë™ë£Œë¥¼ ê³ ìš©í•˜ë ¤ë©´ ${cost} ê³¨ë“œê°€ í•„ìš”í•©ë‹ˆë‹¤.`);
        renderAll();
        return;
      }
      gold -= cost;

      const classes = ['warrior','archer','mage','monk','rogue','guardian','knight'];
      const cls = classes[randInt(0, classes.length-1)];
      const namePool = {
        warrior:['ë¸Œëœ','ì¼€ì¸','ë„ë€'],
        archer:['ì—˜ë¦¬','ë‚˜ì¸','í˜ì¼'],
        mage:['ë¦¬ì•ˆ','ë¯¸ë¼','ìë ˆìŠ¤'],
        monk:['ì‹œì•ˆ','ë³´ë¼','ë¼ì¼'],
        rogue:['ë¦°','ì¹´ì¼','ì œì´ë“œ'],
        guardian:['ë³¼í¬','í•˜ë¥´','ë„ë¯¸ë¥´'],
        knight:['ì•Œë ‰','ì„¸ì‹¤','ë ˆì˜¨']
      };
      const nList = namePool[cls] || ['ë¬´ëª… ìš©ë³‘'];
      const hero = createHero(nList[randInt(0,nList.length-1)], cls);
      party.push(hero);
      partyPositions.push({x:playerX, y:playerY});
      setLog(`ìƒˆë¡œìš´ ë™ë£Œê°€ í•©ë¥˜í–ˆë‹¤! (${hero.name}, ${classLabel(cls)}) (-${cost}G)`);
      renderAll();
    }

    function refreshShop() {
      shopItems = [];
      for (let i=0;i<5;i++) {
        const roll = Math.random();
        if (roll < 0.4) shopItems.push(generateRandomItem(false));
        else if (roll < 0.7) shopItems.push(createPotion());
        else shopItems.push(createScroll());
      }
    }

    function buyFromShop(idx) {
      const item = shopItems[idx];
      if (!item) return;
      if (gold < item.price) {
        setLog('ê³¨ë“œê°€ ë¶€ì¡±í•˜ë‹¤.');
        renderAll();
        return;
      }
      gold -= item.price;
      inventory.push(item);
      shopItems.splice(idx,1);
      setLog(`${item.name}ì„(ë¥¼) êµ¬ë§¤í–ˆë‹¤. (-${item.price} ê³¨ë“œ)`);
      renderAll();
    }

    function setupQuests() {
      quests = [
        { id: nextQuestId++, title: '4ì¸µ ë„ë‹¬ í›„ ê·€í™˜', desc: 'ë˜ì „ 4ì¸µì— ë„ë‹¬í•œ ë’¤ ì‚´ì•„ì„œ ë§ˆì„ë¡œ ëŒì•„ì˜¤ê¸°.', type: 'reachAndReturn', targetFloor: 4, done: false, reward: 120 },
        { id: nextQuestId++, title: 'ë³´ìŠ¤ 1íšŒ ê²©íŒŒ', desc: 'ì–´ë–¤ ì¸µì´ë“  ë³´ìŠ¤ë¥¼ 1íšŒ ì“°ëŸ¬ëœ¨ë¦¬ê¸°.', type: 'killBoss', progress:0, target:1, done:false, reward:150 }
      ];
    }

    function updateQuestsOnReturn() {
      for (const q of quests) {
        if (q.done) continue;
        if (q.type === 'reachAndReturn' && floor >= q.targetFloor) {
          q.done = true;
          gold += q.reward;
          appendLog(`[ì˜ë¢° ì™„ë£Œ] ${q.title} (+${q.reward} ê³¨ë“œ)`);
        }
      }
    }

    function updateQuestsOnKill(monster) {
      for (const q of quests) {
        if (q.done) continue;
        if (q.type === 'killBoss' && monster.isBoss) {
          q.progress = (q.progress||0)+1;
          if (q.progress>=q.target) {
            q.done=true;
            gold += q.reward;
            appendLog(`[ì˜ë¢° ì™„ë£Œ] ${q.title} (+${q.reward} ê³¨ë“œ)`);
          }
        }
      }
    }

    function returnToTown(fromVictory) {
      mode = 'town';
      if (fromVictory) updateQuestsOnReturn();
      drawTown();
      renderAll();
    }

    function enterDungeon() {
      if (!party.length) {
        party = [ createHero('ìš©ì‚¬', 'warrior') ];
      }
      mode = 'dungeon';
      generateDungeon();
      setLog(`${floor}ì¸µ ë˜ì „ì— ì…ì¥í–ˆë‹¤.`);
      renderAll();
    }

    // ===== ë Œë”ë§ =====
    function renderParty() {
      const partyEl = document.getElementById('party');
      let html = `íŒŒí‹° (ê³¨ë“œ: ${gold}, ì¸µ: ${floor})\n`;
      if (!party.length) {
        html += '\në™ë£Œê°€ ì—†ìŠµë‹ˆë‹¤. ë§ˆì„ì—ì„œ ë™ë£Œ ëª¨ì§‘ ë²„íŠ¼ì„ ëˆŒëŸ¬ë³´ì„¸ìš”.';
        partyEl.textContent = html;
        return;
      }
      for (let i=0;i<party.length;i++) {
        const h = party[i];
        const stats = calcHeroStats(h);
        const selClass = i===selectedHeroIndex ? 'party-member selected' : 'party-member';
        html += `<div class="${selClass}" onclick="selectHero(${i})">`
              + `${heroEmoji(h)} ${h.name} (${classLabel(h.cls)}) HP ${h.hp}/${stats.maxHp} ATK ${stats.atk} DEF ${stats.def}`;
        if (h.buffTurns>0) html += ` [ë²„í”„ ${h.buffTurns}í„´]`;
        if (h.status.poison>0) html += ` [ë… ${h.status.poison}í„´]`;
        html += `</div>`;
      }
      partyEl.innerHTML = html;
    }

    function selectHero(i) {
      selectedHeroIndex = i;
      setLog(`${party[i].name}ì„(ë¥¼) ì„ íƒí–ˆë‹¤.`);
      renderAll();
    }

    function renderEquipment() {
      const eqEl = document.getElementById('equipment');
      if (!party.length) {
        eqEl.textContent = 'ì¥ë¹„ (íŒŒí‹° ì—†ìŒ)';
        return;
      }
      const h = party[selectedHeroIndex];
      const eq = h.equipment;
      let html = `ì¥ë¹„ - ${h.name}\n`;
      function line(slotKey, label) {
        const item = eq[slotKey];
        const icon = item ? slotShortIcon(item.slotType) : 'â–«ï¸';
        const rarityCls = item && item.rarity ? rarityClass(item.rarity) : '';
        const name = item ? item.name : 'ì—†ìŒ';
        html += `<div class="slot-line" onclick="unequipSlot('${slotKey}')">`
             + `<span class="slot-name">${label}</span>`
             + `<span class="${rarityCls}">${icon} ${name}</span></div>`;
      }
      line('head','ë¨¸ë¦¬');
      line('chest','ëª¸í†µ');
      line('arms','íŒ”');
      line('legs','ë‹¤ë¦¬');
      line('boots','ì‹ ë°œ');
      line('ring1','ë°˜ì§€1');
      line('ring2','ë°˜ì§€2');
      line('necklace','ëª©ê±¸ì´');
      line('mainHand','ë¬´ê¸°');
      line('offHand','ë³´ì¡°');
      eqEl.innerHTML = html + '<div style="font-size:11px;color:#6b7280;margin-top:2px;">(ìŠ¬ë¡¯ì„ í´ë¦­í•˜ë©´ ì¥ë¹„ í•´ì œ, ì¥ë¹„/ì†Œëª¨í’ˆ ì‚¬ìš©ì€ ì¸ë²¤í† ë¦¬ í´ë¦­)</div>';
    }

    function renderInventory() {
      const invEl = document.getElementById('inventory');
      let html = 'ì¸ë²¤í† ë¦¬\n';
      if (!inventory.length) {
        html += '\n(ë¹„ì–´ ìˆìŒ)';
        invEl.textContent = html;
        return;
      }
      const gears = inventory.filter(it => it.category==='gear');
      const consumables = inventory.filter(it => it.category!=='gear');

      html += '[ì¥ë¹„]\n';
      if (!gears.length) html += '  (ì¥ë¹„ ì—†ìŒ)\n';
      else {
        inventory.forEach((it, idx) => {
          if (it.category!=='gear') return;
          const rc = it.rarity ? rarityClass(it.rarity) : '';
          html += `<div class="item-row"><button class="item-btn ${rc}" onclick="equipOrUseItem(${idx})">${slotShortIcon(it.slotType)} ${it.name} (${rarityLabel(it.rarity)}) - ${itemSummary(it)}</button><button class="sell-btn" onclick="sellItem(${idx})">íŒë§¤</button></div>`;
        });
      }

      html += '\n[ì†Œëª¨í’ˆ]\n';
      if (!consumables.length) html += '  (ì†Œëª¨í’ˆ ì—†ìŒ)\n';
      else {
        inventory.forEach((it, idx) => {
          if (it.category==='gear') return;
          html += `<div class="item-row"><button class="item-btn item-consumable" onclick="equipOrUseItem(${idx})">${slotShortIcon(it.slotType)} ${it.name} - ${itemSummary(it)}</button><button class="sell-btn" onclick="sellItem(${idx})">íŒë§¤</button></div>`;
        });
      }

      invEl.innerHTML = html;
    }

    function renderShop() {
      const shopEl = document.getElementById('shop');
      let html = 'ë§ˆì„ ìƒì \n';
      if (!shopItems.length) html += '\nìƒì ì´ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤. (ì•„ë˜ ë²„íŠ¼ìœ¼ë¡œ ìƒˆë¡œê³ ì¹¨)';
      else {
        shopItems.forEach((it,idx) => {
          const rc = it.rarity ? rarityClass(it.rarity) : (it.category!=='gear' ? 'item-consumable' : '');
          html += `<div class="item-row"><button class="item-btn ${rc}" onclick="buyFromShop(${idx})">${slotShortIcon(it.slotType)} ${it.name} (${it.price}G) - ${itemSummary(it)}</button></div>`;
        });
      }
      html += `<button class="shop-btn" onclick="refreshShop();renderAll();">ìƒì  ìƒˆë¡œê³ ì¹¨</button>`;
      shopEl.innerHTML = html;
    }

    function renderQuests() {
      const qEl = document.getElementById('quests');
      if (!quests.length) {
        qEl.textContent = 'ì˜ë¢° ê²Œì‹œíŒ\n\n(í˜„ì¬ ë“±ë¡ëœ ì˜ë¢°ê°€ ì—†ìŠµë‹ˆë‹¤.)';
        return;
      }
      let html = 'ì˜ë¢° ê²Œì‹œíŒ\n';
      for (const q of quests) {
        html += `<div class="quest-card"><div class="quest-title">${q.done ? 'âœ… ' : 'â¬œ '}${q.title}</div><div class="quest-meta">${q.desc}</div>`;
        if (q.type === 'killBoss') {
          html += `<div class="quest-meta">ì§„í–‰: ${q.progress||0}/${q.target}</div>`;
        }
        html += `<div class="quest-meta">ë³´ìƒ: ${q.reward} ê³¨ë“œ</div></div>`;
      }
      qEl.innerHTML = html;
    }

    function renderRelics() {
      const rEl = document.getElementById('relics');
      let html = 'ìœ ë¬¼\n';
      if (!relics.length) {
        html += '\n(íšë“í•œ ìœ ë¬¼ì´ ì—†ìŠµë‹ˆë‹¤.)';
        rEl.textContent = html;
        return;
      }
      for (const r of relics) {
        html += `- ${r.name}: ${r.desc}\n`;
      }
      rEl.textContent = html;
    }

    function renderHelp() {
      const helpEl = document.getElementById('help');
      helpEl.innerHTML =
`<details open>
  <summary>ì¡°ì‘ë²• ë³´ê¸°</summary>
  <div>
- ì´ë™: ë°©í–¥í‚¤ / WASD
- ëŒ€ê¸°: Space
- ì¸ë²¤í† ë¦¬: ì•„ì´í…œ í´ë¦­ ì‹œ ì¥ë¹„/ì‚¬ìš©
- ì¥ë¹„ í•´ì œ: ì¥ë¹„ ì¹¸ í´ë¦­
- ì¼ë°˜ ì¸µ: ê³„ë‹¨ ë°Ÿìœ¼ë©´ ìë™ìœ¼ë¡œ ë‹¤ìŒ ì¸µ ì´ë™
- ë³´ìŠ¤ ì¸µ: ë³´ìŠ¤ ì²˜ì¹˜ í›„ ê³„ë‹¨ì—ì„œ ë‚´ë ¤ê°€ê¸°/íƒˆì¶œ ì„ íƒ
- ë˜ì „ì—ì„œ ì „ë©¸í•´ë„ ì¼ë¶€ ì•„ì´í…œê³¼ ê³¨ë“œëŠ” ë‚¨ìŠµë‹ˆë‹¤.
  </div>
</details>`;
    }

    function renderAll() {
      document.getElementById('mode').textContent =
        (mode === 'town' ? 'ëª¨ë“œ: ë§ˆì„' : `ëª¨ë“œ: ë˜ì „ ${floor}ì¸µ`);

      if (mode === 'town') drawTown();
      else drawDungeon();

      renderParty();
      renderEquipment();
      renderInventory();
      renderShop();
      renderQuests();
      renderRelics();
      renderHelp();
    }

    // ===== í‚¤ë³´ë“œ ì…ë ¥ =====
    window.addEventListener('keydown', (e) => {
      if (mode !== 'dungeon') return;
      let handled = true;
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') movePlayer(0,-1);
      else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') movePlayer(0,1);
      else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') movePlayer(-1,0);
      else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') movePlayer(1,0);
      else if (e.key === ' ') {
        setLog('ì ì‹œ ì£¼ë³€ì„ ì‚´í•€ë‹¤. (1í„´ ê²½ê³¼)');
        monstersAct();
        recomputeFov();
        renderAll();
      } else handled = false;
      if (handled) e.preventDefault();
    });

    // ===== ì´ˆê¸°í™” =====
    function initGame() {
      // ì‹œì‘ íŒŒí‹°: ìš©ì‚¬ í•œ ëª…
      party = [ createHero('ìš©ì‚¬', 'warrior') ];
      partyPositions = party.map((_,idx)=>({x:0,y:0}));
      refreshShop();
      setupQuests();
      mode = 'town';
      drawTown();
      setLog('ë§ˆì„ì— ë„ì°©í–ˆë‹¤. ë™ë£Œë¥¼ ëª¨ì§‘í•˜ê³  ì¥ë¹„ë¥¼ ê°–ì¶˜ ë’¤ ë˜ì „ì— ë„ì „í•´ ë³´ì!');
      renderAll();
    }

    initGame();
  </script>
</body>
</html>
